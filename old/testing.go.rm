package main

import (
	"fmt"
	"reflect"
	"strings"
)

type Constructor struct{}

type Config interface {
}

type FooConfig struct {
}

type BarConfig struct {
}

type BazConfig struct {
}

type QuuxConfig struct {
}

func (t *Constructor) newFoo(c FooConfig) {
	fmt.Println("foo")
}

func (t *Constructor) newBar(c BarConfig) {
	fmt.Println("bar")
}

func (t *Constructor) newBaz(c BazConfig) {
	fmt.Println("baz")
}

func (t *Constructor) newQuux(c QuuxConfig) {
	fmt.Println("quux")
}

func (t *Constructor) NewThingy(t string, c Config) {
	fooType := reflect.TypeOf(t)
	configType := reflect.TypeOf(c)

	// t is a string referencing the type
	// fmt.Println(reflect.TypeOf(*t))
	for i := 0; i < fooType.NumMethod(); i++ {
		// fmt.Println(i)
		method := fooType.Method(i)

		if strings.HasPrefix(method.Name, "new") {
			fmt.Println(method)
			f := func(fooType, configType) {}
			fmt.Println(f)
		}

		// t_ := method.Type

		// fmt.Println(t_)
		// //fmt.Println(reflect.TypeOf(method.Type))

		// quuz := reflect.TypeOf(func(*Constructor, FooConfig) {})

		// fmt.Println(quuz == t_)
		// fmt.Println("")

		// if quuz == t_ {
		// 	method.Func.Call([]reflect.Value{reflect.ValueOf(&t), reflect.ValueOf(FooConfig{})})
		// }
	}
}

func main() {
	config := FooConfig{}
	var t Constructor
	t.NewThingy(config)

	// var selected string = "foo"

	// var t Constructor
	// // f := func(*Constructor, float64) {}

	// fooType := reflect.TypeOf(&t)
	// for i := 0; i < fooType.NumMethod(); i++ {

	// 	method := fooType.Method(i)

	// 	t_ := method.Type

	// 	fmt.Println(t_)
	// 	//fmt.Println(reflect.TypeOf(method.Type))

	// 	quuz := reflect.TypeOf(func(*Constructor, FooConfig) {})

	// 	fmt.Println(quuz == t_)
	// 	fmt.Println("")

	// 	if quuz == t_ {
	// 		method.Func.Call([]reflect.Value{reflect.ValueOf(&t), reflect.ValueOf(FooConfig{})})
	// 	}
	// }
}
