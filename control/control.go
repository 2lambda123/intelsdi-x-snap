package control

import (
	"crypto/rsa"
	"errors"
	"fmt"
	"strings"

	"github.com/intelsdilabs/gomit"

	"github.com/intelsdilabs/pulse/control/plugin"
	"github.com/intelsdilabs/pulse/control/plugin/client"
	"github.com/intelsdilabs/pulse/control/plugin/cpolicy"
	"github.com/intelsdilabs/pulse/core"
	"github.com/intelsdilabs/pulse/core/cdata"
	"github.com/intelsdilabs/pulse/core/control_event"
)

// control private key (RSA private key)
// control public key (RSA public key)
// Plugin token = token generated by plugin and passed to control
// Session token = plugin seed encrypted by control private key, verified by plugin using control public key
//

type executablePlugins []plugin.ExecutablePlugin

type pluginControl struct {
	// TODO, going to need coordination on changing of these
	RunningPlugins executablePlugins
	Started        bool
	// loadRequestsChan chan LoadedPlugin

	controlPrivKey *rsa.PrivateKey
	controlPubKey  *rsa.PublicKey
	eventManager   *gomit.EventController

	pluginManager managesPlugins
	metricCatalog catalogsMetrics
	pluginRunner  runsPlugins
	pluginRouter  routesToPlugins
}

type routesToPlugins interface {
	Strategy() RoutingStrategy
}

type runsPlugins interface {
	Start() error
	Stop() []error
	AvailablePlugins() *availablePlugins
	AddDelegates(delegates ...gomit.Delegator)
	SetMetricCatalog(c catalogsMetrics)
	SetPluginManager(m managesPlugins)
}

type managesPlugins interface {
	LoadPlugin(string) (*loadedPlugin, error)
	UnloadPlugin(CatalogedPlugin) error
	LoadedPlugins() *loadedPlugins
	SetMetricCatalog(catalogsMetrics)
	GenerateArgs() plugin.Arg
}

type catalogsMetrics interface {
	Get([]string, int) (*metricType, error)
	Add(*metricType)
	AddLoadedMetricType(*loadedPlugin, core.MetricType)
	Item() (string, []*metricType)
	Next() bool
	Subscribe([]string, int) error
	Unsubscribe([]string, int) error
	Table() map[string][]*metricType
	GetPlugin([]string, int) (*loadedPlugin, error)
}

// Returns a new pluginControl instance
func New() *pluginControl {
	c := &pluginControl{}
	// Initialize components
	//
	// Event Manager
	c.eventManager = gomit.NewEventController()

	// Metric Catalog
	c.metricCatalog = newMetricCatalog()

	// Plugin Manager
	c.pluginManager = newPluginManager()
	//    Plugin Manager needs a reference to the metric catalog
	c.pluginManager.SetMetricCatalog(c.metricCatalog)

	// Plugin Runner
	c.pluginRunner = newRunner()
	c.pluginRunner.AddDelegates(c.eventManager)
	c.pluginRunner.SetMetricCatalog(c.metricCatalog)
	c.pluginRunner.SetPluginManager(c.pluginManager)

	// Plugin Router
	c.pluginRouter = newPluginRouter()

	// Wire event manager

	// Start stuff
	err := c.pluginRunner.Start()
	if err != nil {
		panic(err)
	}

	// c.loadRequestsChan = make(chan LoadedPlugin)
	// privatekey, err := rsa.GenerateKey(rand.Reader, 4096)

	// if err != nil {
	// 	panic(err)
	// }

	// // Future use for securing.
	// c.controlPrivKey = privatekey
	// c.controlPubKey = &privatekey.PublicKey

	return c
}

// Begin handling load, unload, and inventory
func (p *pluginControl) Start() error {
	// begin controlling

	// Start load handler. We only start one to keep load requests handled in
	// a linear fashion for now as this is a low priority.
	// go p.HandleLoadRequests()

	// Start pluginManager when pluginControl starts
	p.Started = true
	return nil
}

func (p *pluginControl) Stop() {
	// close(p.loadRequestsChan)
	p.Started = false
}

// Load is the public method to load a plugin into
// the LoadedPlugins array and issue an event when
// successful.
func (p *pluginControl) Load(path string) error {
	if !p.Started {
		return errors.New("Must start Controller before calling Load()")
	}

	if _, err := p.pluginManager.LoadPlugin(path); err != nil {
		return err
	}

	// defer sending event
	event := new(control_event.LoadPluginEvent)
	defer p.eventManager.Emit(event)
	return nil
}

func (p *pluginControl) Unload(pl CatalogedPlugin) error {
	err := p.pluginManager.UnloadPlugin(pl)
	if err != nil {
		return err
	}

	event := new(control_event.UnloadPluginEvent)
	defer p.eventManager.Emit(event)
	return nil
}

func (p *pluginControl) SwapPlugins(inPath string, out CatalogedPlugin) error {

	lp, err := p.pluginManager.LoadPlugin(inPath)
	if err != nil {
		return err
	}

	err = p.pluginManager.UnloadPlugin(out)
	if err != nil {
		err2 := p.pluginManager.UnloadPlugin(lp)
		if err2 != nil {
			return errors.New("failed to rollback after error" + err2.Error() + " -- " + err.Error())
		}
		return err
	}

	event := new(control_event.SwapPluginsEvent)
	defer p.eventManager.Emit(event)

	return nil
}

func (p *pluginControl) generateArgs() plugin.Arg {
	a := plugin.Arg{
		ControlPubKey: p.controlPubKey,
		PluginLogPath: "/tmp/pulse-test-plugin.log",
	}
	return a
}

// SubscribeMetricType validates the given config data, and if valid
// returns a MetricType with a config.  On error a collection of errors is returned
// either from config data processing, or the inability to find the metric.
func (p *pluginControl) SubscribeMetricType(mt core.MetricType, cd *cdata.ConfigDataNode) (core.MetricType, []error) {
	subErrs := make([]error, 0)

	m, err := p.metricCatalog.Get(mt.Namespace(), mt.Version())
	if err != nil {
		subErrs = append(subErrs, err)
		return nil, subErrs
	}

	// No metric found return error.
	if m == nil {
		subErrs = append(subErrs, errors.New(fmt.Sprintf("no metric found cannot subscribe: (%s) version(%d)", mt.Namespace(), mt.Version())))
		return nil, subErrs
	}

	if m.policy == nil {
		m.policy = cpolicy.NewPolicyNode()
	}
	ncdTable, errs := m.policy.Process(cd.Table())
	if errs != nil && errs.HasErrors() {
		return nil, errs.Errors()
	}
	m.config = cdata.FromTable(*ncdTable)

	m.Subscribe()
	e := &control_event.MetricSubscriptionEvent{
		MetricNamespace: m.Namespace(),
		Version:         m.Version(),
	}
	defer p.eventManager.Emit(e)

	return m, nil
}

// UnsubscribeMetricType unsubscribes a MetricType
// If subscriptions fall below zero we will panic.
func (p *pluginControl) UnsubscribeMetricType(mt core.MetricType) {
	err := p.metricCatalog.Unsubscribe(mt.Namespace(), mt.Version())
	if err != nil {
		// panic because if a metric falls below 0, something bad has happened
		panic(err.Error())
	}
	e := &control_event.MetricUnsubscriptionEvent{
		MetricNamespace: mt.Namespace(),
	}
	p.eventManager.Emit(e)
}

// the public interface for a plugin
// this should be the contract for
// how mgmt modules know a plugin
type CatalogedPlugin interface {
	Name() string
	Version() int
	TypeName() string
	Status() string
	LoadedTimestamp() int64
}

// the collection of cataloged plugins used
// by mgmt modules
type PluginCatalog []CatalogedPlugin

// returns a copy of the plugin catalog
func (p *pluginControl) PluginCatalog() PluginCatalog {
	table := p.pluginManager.LoadedPlugins().Table()
	pc := make([]CatalogedPlugin, len(table))
	for i, lp := range table {
		pc[i] = lp
	}
	return pc
}

func (p *pluginControl) MetricCatalog() []core.MetricType {
	var c []core.MetricType
	for p.metricCatalog.Next() {
		_, mts := p.metricCatalog.Item()
		for _, mt := range mts {
			c = append(c, mt)
		}
	}
	return c
}

func (p *pluginControl) MetricExists(mns []string, ver int) bool {
	_, err := p.metricCatalog.Get(mns, ver)
	if err == nil {
		return true
	}
	return false
}

// --------------------------- CollectMetrics -----------------

// CollectMetrics returns metrics
// Metrics returned are gathered from selected available plugin from pool based on startegy in router
func (p *pluginControl) CollectMetrics(metricTypes []core.MetricType) ([]core.Metric, error) {
	// TODO: just a stub to be reimplemented later
	// selection is a mapping from key -> metricTypes
	// selection -> (lp, mts)
	// selections -> key -> (lp, mts)

	// generate selections
	selections, err := groupMetricTypesByLoadedPlugin(metricTypes, p.metricCatalog.GetPlugin)
	if err != nil {
		return nil, err
	}

	// extract plugins keys from selections - something like selections.Keys()
	pluginKeys := []string{}
	for pluginKey := range selections {
		pluginKeys = append(pluginKeys, pluginKey)
	}

	// prepare pools for every pluginKey
	pools, err := getAvailablePluginPools(pluginKeys, p.pluginRunner)
	if err != nil {
		return nil, err
	}

	// TODO: replace with something like this from Joel PR
	// availablePlugins, err := getAvailablePlugins(pools, p.pluginRunner)
	// but for now:
	availablePlugins := []availablePlugin{}
	for _, pool := range pools {
		// choose one availablePlugin to be used for collecting metrics
		ap, err := pool.SelectUsingStrategy(p.pluginRouter.Strategy())
		if err != nil {
			return nil, err
		}
		availablePlugins = append(availablePlugins, *ap)
	}

	// TODO: replace me with something sensbile but that requires changes in Joel code
	// the ugly thing: match every avaiablePlugin and selection.MetricTypes
	// based on index in availablePlugin slice,
	// should be more like a map with pluginKey as key
	// it works only because we assume the same number of selections, pools and available plugins!
	// so a little assertion there
	if len(availablePlugins) != len(selections) {
		return nil, errors.New("assertion failed: expected equal size of collections")
	}

	// collect metrics from availablePlugins
	// response
	metrics := []core.Metric{}
	idx := 0 // availablePlugins index
	for _, selection := range selections {
		// get ap by idx
		ap := availablePlugins[idx]

		// cast ap.client to being collector client
		client, ok := ap.Client.(client.PluginCollectorClient)
		if !ok {
			return nil, errors.New("couldn't cast availablePlugin.Client to PluginCollectorClient!")
		}

		// collect metrics using client casted to CollectorClient
		apMetrics, err := client.CollectMetrics(selection.metricTypes)
		if err != nil {
			return nil, err
		}
		// merge metrics together
		metrics = append(metrics, apMetrics...)
		idx++
	}

	return metrics, nil
}

//
// ----------------- helper private types & functions to support CollectMetrics functionallity -------------
//

type pluginCallSelection struct {
	plugin      *loadedPlugin
	metricTypes []core.MetricType
}

func (p *pluginCallSelection) Count() int {
	return len(p.metricTypes)
}

// loadedPlugin.Key() -> pluginCallSelection
type pluginCallSelections map[string]*pluginCallSelection

// groupMetricTypesByLoadedPlugin - take a bunch of metricTypes and return
// a mapping from loadedPlugin.Key() -> collection of metricTypes (called selection)
// return errors when there is no such metricType available
// actually it is a constructor for collection of pluginCallSelections
func groupMetricTypesByLoadedPlugin(
	metricTypes []core.MetricType,
	getLoadedPlugin func(namespace []string, version int) (*loadedPlugin, error),
) (map[string]*pluginCallSelection, error) {

	// group metricsTypes by loadedPlugin.key (key = name + version)
	selections := pluginCallSelections{}

	// For each plugin type select a matching available plugin to call
	for _, m := range metricTypes {

		// This is set to choose the newest and not pin version. TODO, be sure version is set to -1 if not provided by user on Task creation.
		lp, err := getLoadedPlugin(m.Namespace(), -1)

		// Single error fails entire operation - propagate the error received from catalog
		if err != nil {
			return nil, err
		}

		// Single error fails entire operation - there is plugin to handle these metricTypes
		if lp == nil {
			return nil, errors.New(fmt.Sprintf("Metric missing: %s", strings.Join(m.Namespace(), "/")))
		}

		fmt.Printf("Found plugin (%s v%d) for metric (%s)\n", lp.Name(), lp.Version(), strings.Join(m.Namespace(), "/"))

		// group them
		sel, ok := selections[lp.Key()]
		if ok {
			// selection already exists, just update the collections of metricTypes inside
			sel.metricTypes = append(sel.metricTypes, m)
		} else {
			// create new selection structure
			selections[lp.Key()] = &pluginCallSelection{
				plugin:      lp,
				metricTypes: []core.MetricType{m},
			}

		}
	}
	return selections, nil
}

// getAvailablePluginPools - find a pools for given pluginKeys
func getAvailablePluginPools(pluginKeys []string, runner runsPlugins) ([]*availablePluginPool, error) {

	pools := []*availablePluginPool{}
	for _, pluginKey := range pluginKeys {
		pool, err := getPluginPoolFromRunner(pluginKey, runner)
		if err != nil {
			return nil, err
		}
		pools = append(pools, pool)
	}
	return pools, nil
}

// getPluginPool for loadedPlugin.Key() name+version
// returns the pool which have at least one availablePlugin running
func getPluginPoolFromRunner(
	key string,
	runner runsPlugins,
) (*availablePluginPool, error) {

	// find the right pool by loadedPlugin.Key()
	pool := runner.AvailablePlugins().Collectors.GetPluginPool(key)

	// is pool can be used
	if pool == nil {
		// return error because this plugin has no pool
		return nil, errors.New(fmt.Sprintf("no available plugins for plugin type (%s)", key))
	}

	// Lock this apPool so we are the only one operating on it.
	if pool.Count() == 0 {
		// return error indicating we have no available plugins to call for Collect
		return nil, errors.New(fmt.Sprintf("no available plugins for plugin type (%s)", key))
	}
	return pool, nil
}
